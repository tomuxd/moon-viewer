<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Crater Registry — Viewer</title>
  <link rel="stylesheet" href="styles/style.css" />
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    /* minimal inline styles so page works out-of-the-box */
    html,body { height:100%; margin:0; background:#000; font-family:Inter, system-ui, sans-serif; }
    model-viewer { width:100%; height:100vh; display:block; }
    #infoPanel {
      position: absolute; left:18px; top:18px; z-index: 20;
      background: rgba(0,0,0,0.55); color:#fff; padding:12px 14px; border-radius:8px;
      max-width:320px; box-shadow:0 8px 20px rgba(0,0,0,0.6);
    }
    #craterPopup {
      position: absolute; right:18px; bottom:18px; z-index:30;
      background: rgba(10,10,10,0.88); color:#fff; padding:14px; border-radius:10px;
      width:320px; display:none; box-shadow:0 10px 30px rgba(0,0,0,0.6);
    }
    #craterPopup h3 { margin:0 0 8px 0; font-size:1.05rem; }
    #craterPopup p { margin:6px 0; font-size:0.9rem; color:#ddd; }
    .btn {
      display:inline-block; padding:8px 12px; border-radius:8px; background:#0b84ff; color:white; text-decoration:none;
      border:none; cursor:pointer; font-weight:600;
    }
    .btn.secondary { background:#444; margin-left:8px; }
    .status-available { color: #10b981; font-weight:700; }
    .status-taken { color: #ef4444; font-weight:700; }
  </style>
</head>
<body>
  <!-- model-viewer loads your GLB (self-hosted) -->
  <model-viewer id="moonViewer"
    src="assets/moon.glb"
    alt="3D Moon model"
    camera-controls
    auto-rotate
    rotation-per-second="8deg"
    exposure="1.1"
    environment-image="neutral"
    touch-action="pan-y"
    style="background:#000;">
  </model-viewer>

  <!-- small info panel -->
  <div id="infoPanel">
    <strong>Moon Crater Registry</strong>
    <div style="margin-top:8px; font-size:0.9rem; color:#ddd;">
      Click a crater marker to view details. 
      <span style="color:#10b981">●</span> Available 
      <span style="color:#ef4444">●</span> Taken
      <span style="color:#3b82f6">●</span> Official
    </div>
  </div>

  <!-- Crater popup (in-iframe) -->
  <div id="craterPopup" role="dialog" aria-hidden="true">
    <h3 id="cp-name">Crater Name</h3>
    <p id="cp-coords">Lat / Lon</p>
    <p id="cp-size">Diameter: — km</p>
    <p>Status: <span id="cp-status"></span></p>
    <p>Price: <strong id="cp-price"></strong></p>
    <div style="margin-top:10px;">
      <button id="btnClaim" class="btn">Claim / Buy</button>
      <button id="btnClose" class="btn secondary">Close</button>
    </div>
  </div>

<script type="module">
  // -------------------------
  // CONFIG: allowed parent origins
  // -------------------------
  const ALLOWED_ORIGINS = [
    'https://tomuxd.github.io',
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'https://localhost:3000'
  ];
  // -------------------------

  const viewer = document.querySelector('#moonViewer');
  const popup = document.getElementById('craterPopup');
  const cpName = document.getElementById('cp-name');
  const cpCoords = document.getElementById('cp-coords');
  const cpSize = document.getElementById('cp-size');
  const cpStatus = document.getElementById('cp-status');
  const cpPrice = document.getElementById('cp-price');
  const btnClaim = document.getElementById('btnClaim');
  const btnClose = document.getElementById('btnClose');

  let craterMeshes = [];        // three.js meshes
  let threeRenderer = null;
  let threeScene = null;
  let threeCamera = null;
  let raycaster = null;
  let demoCraters = [];         // loaded from parent
  let selectedCrater = null;

  // utility: lat/lon -> xyz on sphere (assumes model radius ~1)
  function latLonToXYZ(lat, lon, radius=1) {
    const phi = (90 - lat) * (Math.PI / 180);
    const theta = (lon + 180) * (Math.PI / 180);
    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const z = (radius * Math.sin(phi) * Math.sin(theta));
    const y = (radius * Math.cos(phi));
    return { x, y, z };
  }

  // Create crater markers from data
  function createCraterMarkers(craterData) {
    console.log('Creating markers for', craterData.length, 'craters');
    
    // Clear existing markers
    craterMeshes.forEach(mesh => {
      if (mesh.parent) mesh.parent.remove(mesh);
    });
    craterMeshes = [];

    if (!threeScene || !craterData || craterData.length === 0) {
      console.warn('Cannot create markers - missing scene or crater data');
      return;
    }

    demoCraters = craterData;
    const radius = 1.0; // adjust if your model scale differs

    craterData.forEach(crater => {
      const pos = latLonToXYZ(crater.lat, crater.lng, radius);
      const geometry = new THREE.SphereGeometry(0.015, 8, 8);
      
      // Color based on status
      let color;
      if (crater.status === 'available') {
        color = 0x10b981; // green
      } else {
        color = 0xef4444; // red for taken
      }
      
      const material = new THREE.MeshBasicMaterial({ color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(pos.x, pos.y, pos.z);
      mesh.lookAt(0,0,0);
      mesh.userData = crater;
      
      // Add to scene (attach to first child so it rotates with model)
      if (threeScene.children && threeScene.children.length) {
        threeScene.children[0].add(mesh);
      } else {
        threeScene.add(mesh);
      }
      craterMeshes.push(mesh);
    });
    
    console.log('Created', craterMeshes.length, 'crater markers');
  }

  // Create popup content
  function showPopupFor(crater) {
    selectedCrater = crater;
    cpName.textContent = crater.name;
    cpCoords.textContent = `Lat: ${crater.lat.toFixed(4)}, Lon: ${crater.lng.toFixed(4)}`;
    cpSize.textContent = `Diameter: ${crater.diameter} km`;
    cpStatus.textContent = crater.status === 'available' ? 'Available' : 'Taken';
    cpStatus.className = crater.status === 'available' ? 'status-available' : 'status-taken';
    cpPrice.textContent = crater.status === 'available' ? `$${crater.price}` : 'Not for sale';
    popup.style.display = 'block';
    popup.setAttribute('aria-hidden', 'false');

    // set claim button behavior
    if (crater.status === 'available') {
      btnClaim.disabled = false;
      btnClaim.textContent = 'Start Purchase';
      btnClaim.onclick = () => {
        // send message to parent to handle purchase flow
        window.parent.postMessage({ 
          type: 'crater-selected', 
          crater: {
            id: crater.id,
            name: crater.name,
            latitude: crater.lat,
            longitude: crater.lng,
            diameter: crater.diameter,
            isOfficial: false,
            isTaken: crater.status !== 'available',
            takenBy: crater.takenBy,
            price: crater.price
          }
        }, '*');
        popup.style.display = 'none';
      };
    } else {
      btnClaim.disabled = true;
      btnClaim.textContent = 'Unavailable';
      btnClaim.onclick = null;
    }
  }

  btnClose.addEventListener('click', () => {
    popup.style.display = 'none';
    popup.setAttribute('aria-hidden', 'true');
    // reset highlight
    if (craterMeshes.length > 0) {
      craterMeshes.forEach(m => {
        const color = m.userData.status === 'available' ? 0x10b981 : 0xef4444;
        m.material.color.setHex(color);
      });
    }
  });

  // handle messages from parent (controls + crater data)
  window.addEventListener('message', (event) => {
    if (!ALLOWED_ORIGINS.includes(event.origin)) {
      console.log('Message from unauthorized origin:', event.origin);
      return;
    }
    
    const data = event.data || {};
    const { type, value, craterId, craters } = data;
    console.log('Received message:', type, data);

    switch (type) {
      case 'sync-craters':
        console.log('Syncing craters from parent:', craters);
        if (craters && Array.isArray(craters)) {
          createCraterMarkers(craters);
        }
        break;

      case 'zoom':
        // value: 0-100, convert to camera-orbit radius
        const r = 1.0 + (1 - (value/100)) * 2.0; // range ~1-3
        viewer.setAttribute('camera-orbit', `0deg 75deg ${r}m`);
        break;

      case 'rotation':
        // degrees
        viewer.setAttribute('camera-orbit', `${value}deg 75deg auto`);
        break;

      case 'reset':
        viewer.setAttribute('camera-orbit', '0deg 75deg auto');
        break;

      case 'highlight-crater':
        if (!craterMeshes || craterMeshes.length === 0) return;
        // reset all colors
        craterMeshes.forEach(m => {
          const color = m.userData.status === 'available' ? 0x10b981 : 0xef4444;
          m.material.color.setHex(color);
        });
        // highlight specific crater
        if (craterId) {
          const target = craterMeshes.find(m => m.userData.id === craterId);
          if (target) {
            target.material.color.setHex(0x3b82f6); // blue highlight
            showPopupFor(target.userData);
          }
        }
        break;

      default:
        console.log('Unknown parent message', data);
    }
  });

  // once model loads we can access Three internals
  viewer.addEventListener('load', async () => {
    console.log('Model viewer loaded');
    // delay a tick so internals are ready
    await new Promise(r => setTimeout(r, 100));

    // Access internal three.js renderer/scene/camera via model-viewer internals
    try {
      threeRenderer = viewer.renderer?.threeRenderer || viewer.renderer?.renderer;
      threeScene = viewer.scene;
      threeCamera = viewer.getCamera ? viewer.getCamera() : null;
      
      console.log('Three.js internals accessed:', {
        renderer: !!threeRenderer,
        scene: !!threeScene,
        camera: !!threeCamera
      });
    } catch (e) {
      console.warn('Could not access three internals', e);
    }

    // If we couldn't get three objects, fallback
    if (!threeRenderer || !threeScene) {
      console.warn('Three.js internals not accessible');
      // Tell parent we're ready anyway
      window.parent.postMessage({ type: 'iframe-ready' }, '*');
      return;
    }

    // Prepare raycaster
    raycaster = new THREE.Raycaster();

    // click handler using renderer.domElement
    const canvas = threeRenderer.domElement;
    if (canvas) {
      canvas.addEventListener('click', (ev) => {
        if (!raycaster || !craterMeshes || craterMeshes.length === 0) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        
        const camera = viewer.getCamera ? viewer.getCamera() : threeCamera;
        if (!camera) return;
        
        raycaster.setFromCamera(new THREE.Vector2(x,y), camera);
        const intersects = raycaster.intersectObjects(craterMeshes, true);
        
        if (intersects.length) {
          const hit = intersects[0].object;
          // reset colors
          craterMeshes.forEach(m => {
            const color = m.userData.status === 'available' ? 0x10b981 : 0xef4444;
            m.material.color.setHex(color);
          });
          // highlight selected
          hit.material.color.setHex(0x3b82f6);
          const crater = hit.userData;
          showPopupFor(crater);
        }
      });
    }

    // tell parent iframe is ready
    console.log('Sending iframe-ready message');
    window.parent.postMessage({ type: 'iframe-ready' }, '*');
  });

  // accessibility - hide popup on Esc
  window.addEventListener('keydown', (e) => { 
    if (e.key === 'Escape') { 
      popup.style.display='none'; 
    }
  });
</script>
</body>
</html>
